1. Get the application URL by running these commands:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "mcp-prometheus.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
{{- else if contains "LoadBalancer" .Values.service.type }}
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "mcp-prometheus.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "mcp-prometheus.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  echo http://$SERVICE_IP:{{ .Values.service.port }}
{{- else if contains "ClusterIP" .Values.service.type }}
  export POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "{{ include "mcp-prometheus.selectorLabels" . }}" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace {{ .Release.Namespace }} port-forward $POD_NAME 8080:$CONTAINER_PORT
{{- end }}

2. MCP Prometheus Server Configuration:
   - Transport: {{ .Values.app.server.transport }}
   - HTTP Address: {{ .Values.app.server.httpAddr }}
   {{- if eq .Values.app.server.transport "sse" }}
   - SSE Endpoint: {{ .Values.app.server.sseEndpoint }}
   - Message Endpoint: {{ .Values.app.server.messageEndpoint }}
   {{- else if eq .Values.app.server.transport "streamable-http" }}
   - HTTP Endpoint: {{ .Values.app.server.httpEndpoint }}
   {{- end }}

3. Connection Information:
   {{- if eq .Values.app.server.transport "streamable-http" }}
   The MCP server is available via HTTP at:
   {{- if .Values.ingress.enabled }}
   {{- range $host := .Values.ingress.hosts }}
   {{- range .paths }}
   - http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}{{ $.Values.app.server.httpEndpoint }}
   {{- end }}
   {{- end }}
   {{- else }}
   - Use port-forwarding to access: kubectl port-forward svc/{{ include "mcp-prometheus.fullname" . }} 8080:{{ .Values.service.port }}
   - Then connect to: http://localhost:8080{{ .Values.app.server.httpEndpoint }}
   {{- end }}
   {{- else if eq .Values.app.server.transport "sse" }}
   The MCP server is available via SSE at:
   {{- if .Values.ingress.enabled }}
   {{- range $host := .Values.ingress.hosts }}
   {{- range .paths }}
   - http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}{{ $.Values.app.server.sseEndpoint }}
   {{- end }}
   {{- end }}
   {{- else }}
   - Use port-forwarding to access: kubectl port-forward svc/{{ include "mcp-prometheus.fullname" . }} 8080:{{ .Values.service.port }}
   - Then connect to: http://localhost:8080{{ .Values.app.server.sseEndpoint }}
   {{- end }}
   {{- else }}
   The MCP server is configured for stdio transport and requires direct pod access.
   Use: kubectl exec -it {{ include "mcp-prometheus.fullname" . }}-<pod-suffix> -- /mcp-prometheus serve
   {{- end }}

4. Test the MCP Server:
   {{- if ne .Values.app.server.transport "stdio" }}
   # Port-forward to test the server
   kubectl port-forward svc/{{ include "mcp-prometheus.fullname" . }} 8080:{{ .Values.service.port }} -n {{ .Release.Namespace }}
   
   # Test the MCP tools list endpoint
   curl -X POST http://localhost:8080{{ .Values.app.server.httpEndpoint }} \
     -H "Content-Type: application/json" \
     -d '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}'
   {{- else }}
   # Connect directly to the pod for stdio transport
   kubectl exec -it deployment/{{ include "mcp-prometheus.fullname" . }} -n {{ .Release.Namespace }} -- /mcp-prometheus serve
   {{- end }}

5. Environment Variables:
   Configure Prometheus connection by setting environment variables:
   - PROMETHEUS_URL: Your Prometheus server URL
   - PROMETHEUS_ORGID: Organization ID for multi-tenant setups
   - PROMETHEUS_USERNAME: Basic auth username (optional)
   - PROMETHEUS_PASSWORD: Basic auth password (optional)
   - PROMETHEUS_TOKEN: Bearer token for authentication (optional)

6. Health Monitoring:
   {{- if ne .Values.app.server.transport "stdio" }}
   The deployment includes intelligent MCP-specific health probes:
   - Liveness Probe: Tests MCP JSON-RPC functionality every {{ .Values.livenessProbe.periodSeconds | default 30 }}s
   - Readiness Probe: Verifies MCP tools/list endpoint every {{ .Values.readinessProbe.periodSeconds | default 10 }}s
   
   Monitor application health using:
   - Pod status: kubectl get pods -n {{ .Release.Namespace }}
   - Health probe status: kubectl describe pod -n {{ .Release.Namespace }} -l "{{ include "mcp-prometheus.selectorLabels" . }}"
   - Application logs: kubectl logs deployment/{{ include "mcp-prometheus.fullname" . }} -n {{ .Release.Namespace }}
   {{- else }}
   NOTE: Health probes are disabled for stdio transport mode.
   Monitor the application using:
   - Pod status: kubectl get pods -n {{ .Release.Namespace }}
   - Application logs: kubectl logs deployment/{{ include "mcp-prometheus.fullname" . }} -n {{ .Release.Namespace }}
   - Direct MCP test: kubectl exec -it deployment/{{ include "mcp-prometheus.fullname" . }} -n {{ .Release.Namespace }} -- /mcp-prometheus serve
   {{- end }}

7. For more information, visit:
   - Project: https://github.com/giantswarm/mcp-prometheus
   - Documentation: https://github.com/giantswarm/mcp-prometheus/blob/main/README.md
   - Helm Chart README: https://github.com/giantswarm/mcp-prometheus/blob/main/helm/mcp-prometheus/README.md 
